<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shell Noodles (Asteroids-style)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0f18; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud {
      position: fixed; inset: 0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:space-between;
      padding:14px;
      color:#dbe6ff;
      text-shadow: 0 1px 0 rgba(0,0,0,.6);
      font-size:14px;
    }
    .box {
      pointer-events:none;
      background: rgba(10,14,25,.55);
      border: 1px solid rgba(140,170,255,.18);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      max-width: 380px;
    }
    .title { font-weight:700; letter-spacing:.3px; margin:0 0 6px 0; }
    .small { opacity:.85; line-height:1.35; }
    .right { text-align:right; }
    .big {
      position: fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
      color:#eaf1ff;
      text-shadow: 0 2px 0 rgba(0,0,0,.7);
    }
    .big .panel {
      pointer-events:none;
      text-align:center;
      padding:18px 22px;
      border-radius: 16px;
      border: 1px solid rgba(140,170,255,.18);
      background: rgba(10,14,25,.60);
      backdrop-filter: blur(8px);
      max-width: 520px;
      margin: 0 14px;
    }
    .big h1 { margin:0 0 8px 0; font-size: 24px; }
    .big p { margin: 6px 0; opacity:.9; line-height: 1.35; }
    .kbd { display:inline-block; padding: 1px 7px; border-radius: 7px; border:1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.06); font-weight:650; }
    .hidden { display:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div class="box">
    <div class="title">Shell Noodles</div>
    <div class="small">
      Controls (4 commands): <span class="kbd">←</span>/<span class="kbd">→</span> rotate,
      <span class="kbd">↑</span> thrust, <span class="kbd">Space</span> shoot.<br/>
      Tip: Tap thrust to avoid drifting too fast.
    </div>
  </div>
  <div class="box right">
    <div><b>Score:</b> <span id="score">0</span></div>
    <div><b>Lives:</b> <span id="lives">3</span></div>
    <div><b>Wave:</b> <span id="wave">1</span></div>
  </div>
</div>

<div class="big" id="overlay">
  <div class="panel">
    <h1>Click to Focus, Then Play</h1>
    <p>Use <span class="kbd">←</span>/<span class="kbd">→</span> to rotate, <span class="kbd">↑</span> to thrust, <span class="kbd">Space</span> to shoot.</p>
    <p>Clear the screen of shell noodles without getting pasta'd.</p>
    <p style="opacity:.75;margin-top:10px;">(No extra keys required - game starts once the page has focus.)</p>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const waveEl  = document.getElementById('wave');
  const overlay = document.getElementById('overlay');

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // ===== Utilities =====
  const TAU = Math.PI * 2;
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const wrap = (v, max) => (v < 0 ? v + max : (v >= max ? v - max : v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  // ===== Game state =====
  const keys = { left:false, right:false, up:false, space:false };
  let hasFocus = false;

  const ship = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    angle: -Math.PI/2,
    radius: 12,
    invuln: 0
  };

  const bullets = [];
  const noodles = [];
  const particles = [];

  let score = 0;
  let lives = 3;
  let wave = 1;
  let cooldown = 0;
  let gameOver = false;

  function resetShip(center=true) {
    ship.x = center ? window.innerWidth / 2 : ship.x;
    ship.y = center ? window.innerHeight / 2 : ship.y;
    ship.vx = 0; ship.vy = 0;
    ship.angle = -Math.PI/2;
    ship.invuln = 2.0; // seconds
  }

  function startNewGame() {
    score = 0;
    lives = 3;
    wave = 1;
    gameOver = false;
    bullets.length = 0;
    noodles.length = 0;
    particles.length = 0;
    resetShip(true);
    spawnWave(wave);
    syncHUD();
  }

  function syncHUD() {
    scoreEl.textContent = String(score);
    livesEl.textContent = String(lives);
    waveEl.textContent  = String(wave);
  }

  // ===== Noodle obstacles =====
  // "Shell noodle" is rendered as a stylized pasta shell: a curved rim + ridges.
  function createNoodle(sizeTier, x, y) {
    const baseR = sizeTier === 3 ? 46 : (sizeTier === 2 ? 28 : 16);
    const r = baseR * rand(0.85, 1.15);
    const a = rand(0, TAU);
    const speed = (sizeTier === 3 ? rand(18, 42) : sizeTier === 2 ? rand(30, 60) : rand(45, 85));
    const ang = rand(0, TAU);
    const spin = rand(-1.0, 1.0) * (sizeTier === 3 ? 0.6 : sizeTier === 2 ? 1.0 : 1.4);

    return {
      x, y,
      vx: Math.cos(ang) * speed,
      vy: Math.sin(ang) * speed,
      angle: a,
      spin,
      tier: sizeTier,
      r,
      // A little wobble so they feel organic, like pasta that refuses to behave.
      wobble: rand(0, TAU),
      wobbleSpeed: rand(1.2, 2.3),
      // "Hit circle" is slightly smaller than r for fairness.
      hit: r * 0.85,
    };
  }

  function spawnWave(w) {
    const count = 3 + Math.min(8, w); // gradually increases
    for (let i = 0; i < count; i++) {
      // spawn away from center
      let x, y;
      for (let tries = 0; tries < 20; tries++) {
        x = rand(0, window.innerWidth);
        y = rand(0, window.innerHeight);
        if (dist2(x, y, window.innerWidth/2, window.innerHeight/2) > (220*220)) break;
      }
      noodles.push(createNoodle(3, x, y));
    }
  }

  function splitNoodle(n) {
    if (n.tier <= 1) return;
    const newTier = n.tier - 1;
    const pieces = 2 + (Math.random() < 0.35 ? 1 : 0);
    for (let i = 0; i < pieces; i++) {
      const nn = createNoodle(newTier,
        wrap(n.x + rand(-10, 10), window.innerWidth),
        wrap(n.y + rand(-10, 10), window.innerHeight)
      );
      // inherit some momentum
      nn.vx += n.vx * 0.35;
      nn.vy += n.vy * 0.35;
      noodles.push(nn);
    }
  }

  // ===== Effects =====
  function puff(x, y, count, speed, life, colorA, colorB) {
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      const s = rand(speed*0.35, speed);
      particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        t: 0,
        life: rand(life*0.6, life),
        r: rand(1.2, 2.8),
        colorA, colorB,
      });
    }
  }

  function drawStarfield() {
    // lightweight pseudo-starfield based on time & position (no arrays)
    const w = window.innerWidth, h = window.innerHeight;
    const t = performance.now() * 0.00002;
    ctx.fillStyle = '#0b0f18';
    ctx.fillRect(0, 0, w, h);

    const layers = [
      { n: 70, s: 0.15, a: 0.6 },
      { n: 45, s: 0.30, a: 0.7 },
      { n: 25, s: 0.55, a: 0.9 },
    ];

    for (const L of layers) {
      ctx.globalAlpha = L.a;
      for (let i = 0; i < L.n; i++) {
        const fx = (Math.sin(i*999 + t*TAU) * 0.5 + 0.5);
        const fy = (Math.cos(i*777 + t*TAU*1.3) * 0.5 + 0.5);
        const x = fx * w;
        const y = fy * h;
        const r = 1 + (i % 3 === 0 ? 1 : 0);
        ctx.beginPath();
        ctx.arc(x, y, r * L.s * 2.2, 0, TAU);
        ctx.fillStyle = '#dbe6ff';
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }

  // ===== Drawing =====
  function drawShip() {
    const x = ship.x, y = ship.y;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(ship.angle);

    const blink = ship.invuln > 0 ? (Math.floor(performance.now()/120) % 2 === 0) : true;
    ctx.globalAlpha = blink ? 1 : 0.25;

    // ship body
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#dbe6ff';
    ctx.beginPath();
    ctx.moveTo(16, 0);
    ctx.lineTo(-12, -10);
    ctx.lineTo(-7, 0);
    ctx.lineTo(-12, 10);
    ctx.closePath();
    ctx.stroke();

    // engine flame when thrusting
    if (keys.up && !gameOver) {
      ctx.strokeStyle = '#9ad7ff';
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(-20 - rand(0, 6), 0);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawBullet(b) {
    ctx.fillStyle = '#eaf1ff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2.2, 0, TAU);
    ctx.fill();
  }

  function drawNoodle(n) {
    // pasta palette
    const base = 'rgba(235, 212, 160, 0.95)';
    const rim  = 'rgba(255, 240, 210, 0.85)';
    const ridge= 'rgba(195, 160, 105, 0.50)';
    const shadow='rgba(0,0,0,0.25)';

    const wob = Math.sin(n.wobble) * (n.r * 0.07);
    ctx.save();
    ctx.translate(n.x, n.y);
    ctx.rotate(n.angle);

    // shadow
    ctx.fillStyle = shadow;
    ctx.beginPath();
    ctx.ellipse(4, 4, n.r*0.92, n.r*0.65, 0, 0, TAU);
    ctx.fill();

    // main shell body
    ctx.fillStyle = base;
    ctx.beginPath();
    ctx.ellipse(0, 0, n.r*0.95, n.r*0.70, 0, 0, TAU);
    ctx.fill();

    // hollow opening (carved)
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.ellipse(wob*0.15, -wob*0.08, n.r*0.52, n.r*0.32, 0, 0, TAU);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';

    // rim highlight
    ctx.strokeStyle = rim;
    ctx.lineWidth = Math.max(2, n.r * 0.08);
    ctx.beginPath();
    ctx.ellipse(0, 0, n.r*0.92, n.r*0.67, 0, 0, TAU);
    ctx.stroke();

    // ridges
    ctx.strokeStyle = ridge;
    ctx.lineWidth = Math.max(1.2, n.r * 0.045);
    const ridges = Math.floor(6 + n.tier * 2);
    for (let i = 0; i < ridges; i++) {
      const t = (i / (ridges - 1)) * 2 - 1; // -1..1
      const x = t * n.r * 0.70;
      const yTop = -Math.sqrt(Math.max(0, (n.r*0.62)**2 - (x*0.88)**2));
      const yBot =  Math.sqrt(Math.max(0, (n.r*0.62)**2 - (x*0.88)**2));
      ctx.beginPath();
      ctx.moveTo(x, yTop + wob*0.10);
      ctx.lineTo(x, yBot + wob*0.10);
      ctx.stroke();
    }

    // outline
    ctx.strokeStyle = 'rgba(120, 85, 45, 0.28)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.ellipse(0, 0, n.r*0.95, n.r*0.70, 0, 0, TAU);
    ctx.stroke();

    ctx.restore();
  }

  function drawParticles() {
    for (const p of particles) {
      const u = clamp(p.t / p.life, 0, 1);
      const a = 1 - u;
      ctx.globalAlpha = a;
      ctx.fillStyle = (u < 0.5 ? p.colorA : p.colorB);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * (1 + u*0.9), 0, TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // ===== Input =====
  function setKey(e, isDown) {
    // Only the four commands:
    if (e.code === 'ArrowLeft')  keys.left  = isDown;
    if (e.code === 'ArrowRight') keys.right = isDown;
    if (e.code === 'ArrowUp')    keys.up    = isDown;
    if (e.code === 'Space')      keys.space = isDown;
    // prevent page scroll
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'ArrowUp' || e.code === 'Space') {
      e.preventDefault();
    }
  }

  window.addEventListener('keydown', (e) => { setKey(e, true);  hasFocus = true; overlay.classList.add('hidden'); }, { passive:false });
  window.addEventListener('keyup',   (e) => { setKey(e, false); }, { passive:false });

  window.addEventListener('pointerdown', () => {
    // Click focuses and hides overlay. Not a gameplay command.
    hasFocus = true;
    overlay.classList.add('hidden');
    canvas.focus?.();
  });

  window.addEventListener('blur', () => {
    // When tab loses focus, stop thrust/shoot so it doesn't "stick".
    keys.left = keys.right = keys.up = keys.space = false;
  });

  // ===== Mechanics =====
  function shoot() {
    if (cooldown > 0) return;
    cooldown = 0.18;

    const speed = 520;
    const bx = ship.x + Math.cos(ship.angle) * (ship.radius + 6);
    const by = ship.y + Math.sin(ship.angle) * (ship.radius + 6);
    bullets.push({
      x: bx, y: by,
      vx: ship.vx + Math.cos(ship.angle) * speed,
      vy: ship.vy + Math.sin(ship.angle) * speed,
      life: 0.9
    });
  }

  function killShip() {
    lives--;
    syncHUD();
    puff(ship.x, ship.y, 26, 170, 0.9, 'rgba(255,210,170,0.95)', 'rgba(160,210,255,0.9)');

    if (lives <= 0) {
      gameOver = true;
      showGameOverOverlay();
      return;
    }

    // Respawn in center with invulnerability
    resetShip(true);
  }

  function showGameOverOverlay() {
    overlay.classList.remove('hidden');
    overlay.querySelector('h1').textContent = 'Game Over';
    overlay.querySelectorAll('p')[0].innerHTML = `Final score: <span class="kbd">${score}</span>`;
    overlay.querySelectorAll('p')[1].innerHTML =
      `Click to restart. Controls stay the same: <span class="kbd">←</span>/<span class="kbd">→</span>, <span class="kbd">↑</span>, <span class="kbd">Space</span>.`;
    overlay.querySelectorAll('p')[2].textContent =
      'Pro tip: noodles do not have feelings, but your score does.';
    overlay.querySelectorAll('p')[3].textContent =
      '(Restart triggers when you click; no extra keys.)';
  }

  function maybeRestartOnClick() {
    if (!gameOver) return;
    // Restart on the next click after game over.
    const handler = () => {
      window.removeEventListener('pointerdown', handler, true);
      overlay.querySelector('h1').textContent = 'Click to Focus, Then Play';
      overlay.querySelectorAll('p')[0].innerHTML =
        `Use <span class="kbd">←</span>/<span class="kbd">→</span> to rotate, <span class="kbd">↑</span> to thrust, <span class="kbd">Space</span> to shoot.`;
      overlay.querySelectorAll('p')[1].textContent = "Clear the screen of shell noodles without getting pasta'd.";
      overlay.querySelectorAll('p')[2].textContent = '';
      overlay.querySelectorAll('p')[3].textContent = '(No extra keys required - game starts once the page has focus.)';
      overlay.classList.add('hidden');
      startNewGame();
    };
    window.addEventListener('pointerdown', handler, true);
  }

  // ===== Update loop =====
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    const w = window.innerWidth, h = window.innerHeight;

    // background
    drawStarfield();

    if (!gameOver && hasFocus) {
      // ship controls
      const rotSpeed = 4.2; // rad/s
      if (keys.left)  ship.angle -= rotSpeed * dt;
      if (keys.right) ship.angle += rotSpeed * dt;

      // thrust
      if (keys.up) {
        const thrust = 220; // px/s^2
        ship.vx += Math.cos(ship.angle) * thrust * dt;
        ship.vy += Math.sin(ship.angle) * thrust * dt;
      }

      // friction (space-y but playable)
      const damp = Math.pow(0.985, dt * 60);
      ship.vx *= damp;
      ship.vy *= damp;

      // clamp max speed
      const maxV = 320;
      const sp = Math.hypot(ship.vx, ship.vy);
      if (sp > maxV) {
        ship.vx = ship.vx / sp * maxV;
        ship.vy = ship.vy / sp * maxV;
      }

      // move ship
      ship.x = wrap(ship.x + ship.vx * dt, w);
      ship.y = wrap(ship.y + ship.vy * dt, h);

      // invulnerability
      ship.invuln = Math.max(0, ship.invuln - dt);

      // shooting
      cooldown = Math.max(0, cooldown - dt);
      if (keys.space) shoot();

      // update noodles
      for (const n of noodles) {
        n.wobble += n.wobbleSpeed * dt;
        n.angle += n.spin * dt;
        n.x = wrap(n.x + n.vx * dt, w);
        n.y = wrap(n.y + n.vy * dt, h);
      }

      // update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.life -= dt;
        b.x = wrap(b.x + b.vx * dt, w);
        b.y = wrap(b.y + b.vy * dt, h);
        if (b.life <= 0) bullets.splice(i, 1);
      }

      // collisions: bullets vs noodles
      for (let i = noodles.length - 1; i >= 0; i--) {
        const n = noodles[i];
        const hr2 = n.hit * n.hit;

        let hitIndex = -1;
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (dist2(n.x, n.y, b.x, b.y) <= hr2) { hitIndex = j; break; }
        }
        if (hitIndex !== -1) {
          bullets.splice(hitIndex, 1);
          noodles.splice(i, 1);

          // score by tier
          const pts = n.tier === 3 ? 20 : (n.tier === 2 ? 50 : 100);
          score += pts;
          syncHUD();

          puff(n.x, n.y, 18, 140, 0.7, 'rgba(255,240,210,0.95)', 'rgba(190,160,110,0.75)');
          splitNoodle(n);
        }
      }

      // collisions: ship vs noodles
      if (ship.invuln <= 0) {
        for (const n of noodles) {
          const rr = (ship.radius + n.hit) * 0.92;
          if (dist2(ship.x, ship.y, n.x, n.y) <= rr * rr) {
            killShip();
            break;
          }
        }
      }

      // next wave?
      if (!gameOver && noodles.length === 0) {
        wave++;
        syncHUD();
        resetShip(true);
        spawnWave(wave);
        puff(w/2, h/2, 20, 120, 0.9, 'rgba(160,210,255,0.9)', 'rgba(255,240,210,0.85)');
      }
    }

    // update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.97, dt * 60);
      p.vy *= Math.pow(0.97, dt * 60);
      if (p.t >= p.life) particles.splice(i, 1);
    }

    // draw noodles, bullets, ship, particles
    for (const n of noodles) drawNoodle(n);
    for (const b of bullets) drawBullet(b);
    drawShip();
    drawParticles();

    // subtle vignette
    ctx.save();
    const grd = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.15, w/2, h/2, Math.max(w,h)*0.7);
    grd.addColorStop(0, 'rgba(0,0,0,0)');
    grd.addColorStop(1, 'rgba(0,0,0,0.45)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    // restart logic
    if (gameOver) maybeRestartOnClick();

    requestAnimationFrame(tick);
  }

  // Start!
  resetShip(true);
  spawnWave(wave);
  syncHUD();
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
